# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eVnh63PiJIGD1Q-6nBb4GDGP64Ehgatl
"""

global UID
UID = 117600384
global First_Name
First_Name = 'Jash'
global Last_Name
Last_Name = 'Bhesndadia'

# we want to define the main building block of the feistel cipher as a function with 3 inputs and 2 outputs
def feistel_block(LE_inp, RE_inp, k):
  # Does the necessary operations
    for i in range(16):
        dig = F(RE_inp,k[i])
        xoor =  xor(LE_inp,dig)
        LE_inp = RE_inp
        RE_inp = xoor
    LE_out = RE_inp 
    RE_out = LE_inp 

    return LE_out, RE_out

def feistel_blockd(LE_inp, RE_inp, k):
  # Does the necessary operations
    for i in range(16):
        dig = F(RE_inp,k[15-i])
        xoor =  xor(LE_inp,dig)
        LE_inp = RE_inp
        RE_inp = xoor
    LE_out = RE_inp 
    RE_out = LE_inp 

    return LE_out, RE_out

def xor(byteseq1, byteseq2):
  #print(byteseq1)
  #print(byteseq2)
  # Python already provides the ^ operator to do xor on interger values
  # but first we need to break our input byte sequences into bye size integers
  l1 = [b for b in byteseq1]
  l2 = [b for b in byteseq2]
  l1attachl2 = zip(l1,l2)
  # zip(l1,l2) is actually a list as [(b'\xaa',b'\xcc), (b'\x33', b'\x55')]
  #print(l1)
  #print(l2)
  #print(l1attachl2)

  l1xorl2 = [bytes([elem1^elem2]) for elem1,elem2 in l1attachl2]
  #print(l1xorl2)

  result = b''.join(l1xorl2)
  #print(result)

  return result






# As we discussed, feistel operation doesn't depend on the choice of the F function (its encryption strength does)
# Let's all use the same function that uses a good mixing operation using hash functions that we will learn later
import hmac
import hashlib
import random

def F(byteseq, k):
  # we use the hmac hash (don't worry about the meaning for now)
  h = hmac.new(k, byteseq, hashlib.sha1)
  # return the first 8 bytes of the hash value
  return h.digest()[:8]

#foutput = F(b'\x23', b'\x45')
#print(foutput)

# In a real Feistel implementation, different keys are used in different rounds. Here
# we use 64bit keys so for 16 rounds, we need 16 random 8byte keys. We can just generate
# 16 random 8 byte numbers we use the random.randint() function to be able to set the seed
# value and create the same keys for both the encoder and the decoder
def gen_keylist(keylenbytes, numkeys, seed):
    # We need to generate numkeys keys each being keylen bytes long
    keylist = []
    random.seed(seed)
    
    # Use the random.randint(min,max) function to generate individual
    # random integers in range [min, max]. Generate a list of numkeys
    # random byte sequences each of them keylenbytes bytes long to be used as 
    # keys for numkeys stages of the feistel encoder. To make sure we have control over
    # the generated random numbers meaning that the same sequence is 
    # generated in different runs of our program, 
    
    # keylist = [numkeys elements of 'bytes' type and keylenbytes bytes long each]
    keylist = []
    for i in range(numkeys):
        bytelist = b''.join([bytes([random.randint(0,255)]) for x in range(keylenbytes)])
        keylist.append(bytelist)

    return keylist

# Now the actual encoder
def feistel_enc(inputbyteseq, num_rounds, seed):
    # This is the function that accepts one bloc of plaintext
    # and applies all rounds of the feistel cipher and returns the
    # cipher text block. 
    # Inputs:
    # inputblock: byte sequence representing input block
    # num_rounds: integer representing number of rounds in the feistel 
    # seed: integer to set the random number generator to defined state
    # Output:
    # cipherblock: byte sequence
    
    # first generate the required keys
    while len(inputbyteseq)%16 != 0:
            inputbyteseq += b'\x20'
    keylist = gen_keylist(8, num_rounds, seed)

    n = int(len(inputbyteseq)//2) 
    L1 = inputbyteseq[0:n] 
    R1 = inputbyteseq[n::]
    LE_out,RE_out = feistel_block(L1, R1, keylist)
    cipherblock = LE_out + RE_out
    


    # implement num_rounds of calling the block function
    return cipherblock

def feistel_dec(inputbyteseq, num_rounds, seed):

  # Make sure you use the keys in reverse order during decryption
  keylist = gen_keylist(8, num_rounds, seed)
  n = int(len(inputbyteseq)//2) 
  L1 = inputbyteseq[0:n] 
  R1 = inputbyteseq[n::]
  LE_out,RE_out = feistel_blockd(L1, R1, keylist)
  plaintext = LE_out + RE_out
  # apply the num_rounds times of the block funciton

  return plaintext